Retirado de: Ruby on Rails Tutorial - Learn Rails by Example

rails new demo_app
cd demo_app

vi Gemfile  >>>>>
gem 'rails', '3.0.9'
gem 'sqlite3', '1.3.3'
<<<<<
bundle install

git init
git add .
git commit -m "Initial commit"

GitHub  >>>>>
Criei um novo repositório.
<<<<<
git config --global user.name "Fabio Lima"
git config --global user.mail fabionl@gmail.com
touch README 
git remote add origin git@github.com:fabionl/demo_app.git
git push -u origin master
>>>>>>>>
No meu caso deu problema e tive de seguir a orientação no github para configurar o ssh.
<<<<<<<<<

rails generate scaffold User name:string email:string
bundle exec rake db:migrate    >>>>>>
Testei a versão rake utilizado pelo bundle e o padrao do sistema e eram iguais.
a partir de agora, passo a usar o rake diretamente.
<<<<<
rails s
Browser: localhost:3000  >>>>>>
Abriu a página inicial do Rails.
<<<<<<<
rake -T db    >>>>>
Comando do db disponíveis.
<<<<<
rake -T    >>>>>>
Comandos disponíveis.
<<<<<

>>>>>>>
Criei alguns users.
<<<<<<<

rails generate scaffold Micropost content:string user_id:integer
rake db:migrate

>>>>>>>
Fazendo as alterações aos models.
<<<<<<<

git add .
git commit -a -m "Done with the demo app"
git push



****************************************************************************
****************************************************************************
****************************************************************************

*****===> 2011/08/02

rails new sample_app -T       >>>>>>>>  -T serve para não gerar o test directory
cd sample_app

vi Gemfile     >>>>>>>>
gem 'sqlite3', '1.3.3'

group :development do
  gem 'rspec-rails', '2.6.1'
end

group :test do
  gem 'rspec-rails', '2.6.1'
  gem 'webrat', '0.7.1'
end
<<<<<<<<<
bundle install
rails generate rspec:install

git init
git add .
git commit -m "Initial commit"

vi README   >>>>>>>>>>
    Substituição do Texto para uma descrição do Aplicativo, usando markdown.
<<<<<<<<
git mv README README.markdown
git commit -a -m "Improved the README"

git remote add origin git@github.com:fabionl/sample_app.git
git push origin master

git checkout -b static-pages    >>>>>> Criando um novo Topic Branch. A partir daqui o git tá focando nesse Topic Branch

rails generate controller Pages home contact
browser localhost:3000/pages/home    >>>>>>>>>
Apresentou uma página "place holder" da view.
<<<<<<<<<

git add .
git commit -m "Added a Pages controller"



*****===> 2011/08/03

vi Gemfile  >>>>>>>> Tentando autotest.
group :development, :test do
  gem 'autotest', '>= 4.4.6'
  gem 'autotest-rails-pure', '>= 4.1.2'
end
<<<<<<<<<<<<<
bundle install

vi Gemfile  >>>>>>>> Tentando autotest.
group :development, :test do
  # Especifico para o MacOSX
  gem 'autotest-fsevent', '>= 0.2.4'
  gem 'autotest-growl', '>= 0.2.9'
end
<<<<<<<<<<<<<
bundle install

vi .autotest     >>>>>>>>
require 'autotest-growl'
require 'autotest-fsevent'
<<<<<<<<<
git rm -r spec/views
git rm -r spec/helpers

rspec spec/     >>>>>  Executando os testes:
Pode-se usar outras opções:
rspec spec/controllers
rspec spec/controllers/pages_controller_spec.rb
<<<<<
autotest >>>>>>>>>>>>
No meu caso, deu uma mensagem de erro.
Rodei:
gem update --system

Isso resolveu o problema.
<<<<<<<<<<<<

vi Gemfile    >>>>>>>>  Instalando o Spork agora (aumentando velocidade dos testes)
group :test do
  gem 'spork', '>= 0.9.0.rc8'
end
<<<<<<<<
bundle exec spork --bootstrap
vi spec/spec_helper.rb    >>>>>>>>>>
Copiei todo o conteúdo do final do arquivo para dentro de:
Spork.prefork
<<<<<<<<<

time rspec spec/         >>>>>>>
Medidas de Tempo sem o Spork
<<<<<<
bundle exec spork
time rspec --drb spec/   >>>>>>>
Muito mais rápido agora. Tudo funcionando.
<<<<<<
vi .rspec    >>>>>>>>  Fazendo o rspec usar o spork by default.
--color
--drb
<<<<<<<<<
time rspec spec/    >>>>>>>  Funcionando!

>>>>> Agora mantenho 2 janelas terminal abertas, uma com spork e outra com autotest.


>>>>>>>>>  Fazendo um test que vai falhar.
vi spec/controllers/pages_controller_spec.rb    >>>>>>>>>
# O render_views, faz testar as views e não só os controllers.
describe PagesController do
  render_views

  describe "GET 'about'" do
    it "should be successful" do
      get 'about'
      response.should be_success
    end
  end
end
<<<<<<
>>>>>>>>>>>>>  OBS:
Importante notar que ao modificar views, precisa-se 'tocar' no controller para causar o autotest.
É preciso abrir o arquivo do controller e salvá-lo novamente.
<<<<<<<<<<<<<

>>>
Editei page_controller.rb para incluir def about.
Editei routes.rb para incluir get "pages/about"
Editei about.html.erb para incluir uma view simples.
<<<
Browser localhost:3000/pages/about

>>>>>>>>>>>>>>>>>>> Alterando os Titulos

>>>>
Page      URL             Base Title   Variable Title
=======================================================
Home     /pages/home      Sample App      | Home
Contact  /pages/contact   Sample App      | Contact
About    /pages/about     Sample App      | About
<<<<

vi pages_controler_spec.rb
vi application.html.erb

git add .     >>>>>>> Tudo ok. Git neles
git commit -m "Done with static pages"

git checkout master              >>> Mudando para o master branch
git merge static-pages           >>> Fazendo o merge do static-pages para o master branch
git push                         >>> Manda pro GitHub

>>>>>>> Copiei o blueprint CSS/blueprint/ para o public/stylesheets



***** Chapter 5 agora - Trabalhando no Layout

git checkout -b filling-in-layout     >>>> Criando um branch

>>>> Acrescentei uma estrutura básica no html do layout
>>>> Acrescentei os css's e passei parte da estrutura para partials.

>>>>> Hora dos Integration Tests  (requests specs)
rails generate integration_test layout_links

>>>> Escrevi os integrations tests no arquivo geram, apareceram os erros.
vi spec/requests/layout_links_spec.rb  >>>>>>>>>>> Um Exemplo:
  it "should have a Home page at '/'" do
    get '/'
    response.should have_selector('title', :content => 'Home')
  end
<<<<<<<<

>>> O tutotial indica o que fazer caso o autotest não execute os Integration Tests, no meu caso funcionou.

vi routes.rb  >>>>>>>>>>>>>
  match '/contact', :to => 'pages#contact'
  match '/about',   :to => 'pages#about'
  match '/help',    :to => 'pages#help'
  
  root :to => 'pages#home'
<<<<<<<<<<<

git rm public/index.html
git commit -m "Removed default Rails page"

>>>>>> Alterei os links nos layouts (header, footer, etc). Usando sempre o link_to e apontando para os atalhos criados (contact_path, about_path, root_path, etc)

>>>> Criando o Sign up
rails generate controller Users new
rm -rf spec/views
rm -rf spec/helpers

vi users_controller_spec.rb



*****===> 2011/08/04

>>> Criando o Signup.
vi users_controller_spec.rb >>>>>>>>> Criando o Spec do Signup
	it "should have the right title" do
	  get 'new'
	  response.should have_selector("title", :content => "Sign up")
	end
<<<<<<<<  RED
vi users_controller.rb  >>>>>>>>
  def new
    @title = "Sign up"
  end
<<<<<<<<  GREEN
vi layout_links_spec.rb   >>>>>>>> Criando o Integration Test
describe "LayoutLinks" do
  it "should have a signup page at '/signup'" do
    get '/signup'
    response.should have_selector('title', :content => "Sign up")
  end
end
<<<<<<<  RED
vi routes.rb     >>>>>>>>>>   Acrescentando a rota para o signup
  match '/signup',  :to => 'users#new'
<<<<<<<<<<  GREEN
vi pages/home.html.erb    >>>>>> Adicionando o link para o signup.
<%= link_to "Sign up now!", signup_path, :class => "signup_button round" %>
<<<<<<<<<<
>>>>>>>> Fazendo o commit e o merge no git.
rspec spec/          >>>>  GREEN
git add .
git commit -m "Finished layout and routes"
git checkout master
git merge filling-in-layout
git push       >>>> GitHub

git checkout -b exercises_5_5    >>>>>>>  Criando um Branch para os Exerc√≠cios (5.5) do tutorial

vi _header.html.erb     >>>>>  tirei a defini√ß√£o da logo (img)
vi application_helper.rb   >>>>>>
  def logo
    image_tag("logo.png", :alt => "Sample App", :class => "round")
  end
<<<<<
vi layout_links_spec.rb    >>>>>> Tests dos links.
  it "should have the right links on the layout" do
    visit root_path
    click_link "About"
    response.should have_selector('title', :content => "About")
    click_link "Help"
    response.should have_selector('title', :content => "Help")
    click_link "Contact"
    response.should have_selector('title', :content => "Contact")
    click_link "Home"
    response.should have_selector('title', :content => "Home")
    click_link "Sign up now!"
    response.should have_selector('title', :content => "Sign up")
  end
<<<<<<<   GREEN

rspec spec/     >>>> GREEN
git add .
git commit -m "Terminados os Exercicios (5.5) do tutorial. criando helper pra logo e testando os links das p√°ginas"
git checkout master
git merge exercises_5_5
git push     >>>> GitHub


>>>>>>>  Capitulo 6. - Modeling and viewing users, part I
git checkout master
git checkout -b modeling-users    >>> Criando o Branch

rails generate model User name:string email:string
rake db:migrate

vi Gemfile    >>>>>>  Adicionando o GEM Annotate -> Annotates Models
group :development do
  gem 'annotate', '>= 2.4.0'
end
<<<<<<
bundle install

>>>>>  No meu caso, o comando 'annotate' deu um problema. rodei 'gem update' (sem --system), mas nao funcionou, vou ficar com o comando do tutorial mesmo, por enquanto.
bundle exec annotate --position before     >>> Executando o annotate.

vi user.rb    >>>>>>  Definindo os atributos acess√≠veis ao usu√°rio.
  attr_accessible :name, :email
<<<<<

bundle exec rake db:test:prepare     >>>> Garantindo que o db de test está atualizado.

vi user.rb    >>> Escrevendo o validation 
  # validates :name, :presence => true
<<<
vi user_spec.rb   >>> Escrevendo o test para a validação, deixando o test do name como pending
describe User do
  #pending "add some examples to (or delete) #{__FILE__}"
  
  before(:each) do
    @attr = { :name => 'Example User', :email => 'user@example.com' }
  end

  it "should create a new instance given valid attributes" do
    User.create!(@attr)
  end

  it "should require a name"

end
<<<  1 PENDING

vi user_spec.rb    >>>> Escrevendo o test da validação agora.
  it "should require a name" do
    no_name_user = User.new( @attr.merge(:name => '') )
    no_name_user.should_not be_valid
  end
<<<<<   RED

vi user_spec.rb   >>>> Escrevi um test equivalente para o email.
vi user.rb   >>> Escrevendo a validação
   validates :name, :presence => true
   validates :email, :presence => true
<<<   GREEN

vi user_spec.rb  >>>> Test de validação do tamanho do nome
  it "should reject names that are too long" do
    long_name = 'a' * 51
    long_name_user = User.new( @attr.merge(:name => long_name) )
    long_name_user.should_not be_valid
  end
<<<<  RED
vi user.rb  >>>> Fiz a validação do tamanho do campo
<<<<  GREEN
vi user_spec.rb  >>>> Fiz o Teste da validação do email
<<<<  RED
vi user.rb  >>>> Fiz a validação do email
<<<<  GREEN
>>>>  Fiz os teste para garantir uniqueness no email. (case sensitive - 2 testes)
<<< RED
>>>>  Fiz a validação de uniqueness do email.
<<< GREEN



*****===> 2011/08/05

>>>>>  Alterando o DB para garantir o Uniqueness
rails generate migration add_email_uniqueness_index
rake db:migrate

vi application_html.erb    >>>> Incluindo Informações de Debug no Layout
    <%= debug(params) if Rails.env.development? %>
<<<<
>>>>>>>>>  Inclui um cliente de exemplo.
vi users_controller.rb   >>>>>>  Incluindo o metodo show.
  def show
    @user = User.find( params[:id] )
  end
<<<<<<<
vi show.html.erb       >>>>>>  Incluindo a view para mostrar o cliente.
<<<<<
vi routes.rb      >>>>>>   Acrescentando REST para users.
  resources :users   #> Retirar get 'users/new'
<<<<<<

git add .
git commit -m "Finished first cut of the User model"

>>>>>>>>>>>>  Chapter 7 - Modeling and viewuing users, part II
*** ATENÇÃO: Section 13.3 fala sobre o authentication que está sendo introduzido pelo Rails 3.1. (has_secure_password)

rake db:reset    >>> Resetando o db, removendo os registros temporarios.

vi user_spec.rb     >>>>>  Fazendo os tests para o password.
  before(:each) do
    @attr = {
      :name  => 'Example User',
      :email => 'user@example.com',
      :password => 'foobar',
      :password_confirmation => 'foobar'
    }
  end

  describe 'password validations' do
    it 'should require a password' do
      User.new( @attr.merge(:password => '', :password_confirmation => '') ).should_not be_valid
    end
    it 'should require a matching password confirmation' do
      User.new( @attr.merge(:password_confirmation => 'invalid') ).should_not be_valid
    end
    it 'should reject short passwords' do
      short = 'a' * 5
      hash = @attr.merge( :password => short, :password_confirmation => short )
      User.new(hash).should_not be_valid
    end
    it 'should reject long passwords' do
      long = 'a' * 41
      hash = @attr.merge( :password => short, :password_confirmation => short )
      User.new(hash).should_not be_valid
    end
  end
<<<<<<   RED (4)
vi user.rb        >>>>  Incluindo attributos virtuais e uma validação para o password (password_confirmation)
  attr_accessor :password
  attr_accessible :name, :email, :password, :password_confirmation

  validates :password, :presence     => true,
                       :confirmation => true,
                       :length       => { :within => 6..40 }
<<<<  GREEN
vi user_spec     >>>> Testando o campo encrypted_password
  describe 'password encryption' do
    before(:each) do
      @user = User.create!( @attr )
    end
    it 'should have an encrypted password attribute' do
      @user.should respond_to(:encrypted_password)
    end
  end
<<<<   RED

rails generate migration add_password_to_users encrypted_password:string   >>> Gerando o campo encrypted_password
rake db:migrate
rake db:test:prepare

rspec spec/models/user_spec.rb -e 'should have an encrypted password attribute'  >>> Executa o teste específico do campo encrypted_password
<<<<<  GREEN

vi user_spec.rb      >>> Testando se encrypted password não aceita blank.
  describe 'password encryption' do
    it 'should set the encrypted password' do
      @user.encrypted_password.should_not be_blank
    end
<<<   RED
vi user.rb    >>> Adicionando um callback para salvar o encrypted_password
  before_save :encrypt_password
  private
    def encrypt_password
      self.encrypted_password = encrypt(password)
    end
    def encrypt(string)
      string   # Only a temporary implementation!
    end
<<<    GREEN

vi user.rb   >>>> Adicionando um metodo para comparar os passwords
  def has_password?(submitted_password)
    # Compare encrypted_password with the encrypted version of submitted_password.
  end
<<<<
vi user_spec.rb     >>> Testando se has_password? retorna true ou false.
  describe 'password encryption' do
    describe 'has_password? method' do
      it 'should be true if the passwords match' do
        @user.has_password?( @attr[:password] ).should be_true
      end
      it 'should be false if the passwords dont match' do
        @user.has_password?( 'invalid' ).should be_false
      end
    end
<<<    RED

>>>> Gerando o campo salt
rails generate migration add_salt_to_users salt:string
rake db:migrate
rake db:test:prepare
<<<<
vi user.rb    >>>>> Implementando has_password?
require 'digest'   # Para uso da criptografia. (SHA2)

  def has_password?(submitted_password)
    encrypted_password == encrypt( submitted_password )
  end

  private
    def encrypt_password
      self.salt = make_salt if new_record?
      self.encrypted_password = encrypt(password)
    end
    def encrypt(string)
      secure_hash( "#{salt}--#{string}" )   # Only a temporary implementation!
    end
    def make_salt
      secure_hash( "#{Time.now.utc}--#{password}" )
    end
    def secure_hash(string)
      Digest::SHA2.hexdigest(string)
    end
<<<<<   GREEN
rails console --sandbox    >>> Roda o console sem salvar alterações no DB
<<<<< Foi usado só pra testar o caso de uso.

vi user_spec     >>> Escrevendo o teste para o User.authenticate(email, submitted_password)
  describe 'password encryption' do
    describe 'authenticate method' do
      it 'should return nil on email/password mismatch' do
        wrong_password_user = User.authenticate( @attr[:email], 'wrongpass')
        wrong_password_user.should be_nil
      end
      it 'should return nil for an email with no user' do
        nonexistent_user = User.authenticate( 'bar@foo.com', @attr[:password] )
        nonexistent_user.should be_nil
      end
      it 'should return user on email/password match' do
        matching_user = User.authenticate( @attr[:email], @attr[:password] )
        matching_user.should == @user
      end
    end
<<<<<<   RED (3)
vi user.rb   >>>>  Criando o método authenticate. OBS: self é usado para criar como class method.
  def self.authenticate(email, submitted_password)
    user = find_by_email(email)
    return nil if user.nil?
    return user if user.has_password?(submitted_password)
  end
<<<<  GREEN

vi Gemfile   >>>> Adicionando gem factory Girl para os tests
group :test do
  gem 'factory_girl_rails', '1.0'
<<<<
bundle install

vi factories.rb    >>>>> Populando db de teste
Factory.define :user do |user|
  user.name                   'Michael Hartl'
  user.email                  'mhartl@example.com'
  user.password               'foobar'
  user.password_confirmation  'foobar'
end
<<<<<

vi users_controller_spec.rb   >>>>> Usando a factory para os testes.
  describe "GET 'show'" do
    before(:each) do
      @user = Factory(:user)
    end
    it 'should be successful' do
      get :show, :id => @user
      response.should be_success
    end
    it 'should find the right user' do
      get :show, :id => @user
      assigns(:user).should == @user
    end
  end
<<<<<    GREEN

>>>>>>>>> Melhorando a view Show
rake db:reset
User.create!(:name => 'Example User', :email => 'user@example.com', :password => 'foobar', :password_confirmation => 'foobar')

vi users_controller_spec.rb    >>>>>   Checando os elementos da página.
  describe "GET 'show'" do
    it 'should have the right title' do
      get :show, :id => @user
      response.should have_selector('title', :content => @user.name)
    end
    it "should include the user's name" do
      get :show, :id => @user
      response.should have_selector('h1', :content => @user.name)
    end
    it 'should have a profile image' do
      get :show, :id => @user
      response.should have_selector('h1>img', :class=> 'gravatar')
    end
<<<<<   RED (3)
vi users_controller.rb    >>>>  Definindo o @title no method show
  def show
    @user = User.find( params[:id] )
    @title = @user.name
  end
<<<<   RED (2)
vi show.html.erb    >>>>>
<h1>
  <%= @user.name %>
</h1>
<<<<<   RED

vi Gemfile   >>>> adicionando a gem gravatar_image_tag para utilizar o Gravatar
gem 'gravatar_image_tag', '>= 1.0.0.pre2'
<<<<
bundle install

vi users_helper.rb     >>> helper pro gravatar
  def gravatar_for( user, options = { :size => 50} )
    gravatar_image_tag( user.email.downcase, :alt => user.name,
                                             :class => 'gravatar',
                                             :gravatar => options)
  end
<<<
vi show.html.erb    >>>>  Incluindo o gravatar na view
<h1>
  <%= gravatar_for @user %>
  <%= @user.name %>
</h1>
<<<<    GREEN

vi show.html.erb    >>>>  Adding a sidebar to the user show view
<table class='profile' summary='Profile information'>
  <tr>
    <td class='main'>
	  <h1>
		<%= gravatar_for @user %>
		<%= @user.name %>
	  </h1>
    </td>
    <td class='sidebar round'>
      <strong>Name</strong> <%= @user.name %><br/>
      <strong>URL</strong> <%= link_to user_path( @user ), @user %>
    </td>
  </tr>
</table>
<<<<
vi custom.css    >>>> CSS styling the user show page

git branch     >>> Verificando se estamos no branch correto.
git add .
git commit -m "User model with passwords, and user show page"
git checkout master
git merge modeling-users
git push     >>> GitHub


>>>>>>>>> Capitulo 8 - Sign up

bundle exec rake db:reset     >>> ou 'rake db:reset'   tanto faz.

git checkout master
git checkout -b signing-up

vi new.html.erb     >>>  Criando o form de signup
  .
  .
  .
  # Tudo normal até esses 2 campos.
  <div class='field'>
    <%= f.label :password %><br/>
    <%= f.password_field :password %>
  </div>
  <div class='field'>
    <%= f.label :password_confirmation, 'Confirmation' %><br/>
    <%= f.password_field :password_confirmation %>
  </div>
  .
  .
  .
<<<
vi users_controller.rb    >>>> Adicionando @user à action new
  def new
    @user = User.new
<<<
vi custom.css     >>>   Styling o Form
div.field, div.actions {
  margin-bottom: 10px;
}
<<<<
vi users_controller_spec.rb     >>>>>
  describe "POST 'create'" do
    describe 'failure' do
      before(:each) do
        @attr = { :name => '', :email => '', :password => '', :password_confirmation => '' }
      end
      it 'should not create a user' do
        lambda do
          post :create, :user => @attr
        end.should_not change(User, :count)
      end
      it 'should have the right title' do
        post :create, :user => @attr
        response.should have_selector('title', :content => 'Sign up')
      end
      it "should render the 'new' page" do
        post :create, :user => @attr
        response.should render_template('new')
      end
    end
  end
<<<<  RED (3)
vi users_controller.rb    >>> Acrescentando o metodo create   def create
    @user = User.new( params[:user] )
    if @user.save
      # Handle a successful save.
    else
      @title = 'Sign up'
      render 'new'
    end
  end
<<<  GREEN
vi new.html.erb   >>> Acrescentando os erros ao form
<%= form_for(@user) do |f| %>
  <%= render 'shared/error_messages' %>
<<<
vi shared/_error_messages.html.erb   >>> Partial para mostrar os error messages
<% if @user.errors.any? %>
  <div id='error_explanation'>
    <h2><%= pluralize(@user.errors.count, 'error') %> prohibited this user from being saved:</h2>
    <p>There were problems with the following fields:</p>
    <ul>
    <% @user.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
<% end %>
<<<



*****===> 2011/08/06

vi custom.css   >>> Styling as error messages

>>>>  OBS: em config/application.rb, pode-se usar config.fileter_parameters += [:password, etc] para filtrar dados que não devem ser copiados para os logs. Exemplo, nesse caso, são os campos :password.
<<<<

vi users_controller_spec.rb   >>>> Tests for signup success
    describe 'success' do
      before(:each) do
        @attr = { :name => 'New User', :email => 'user@example.com',
                  :password => 'foobar', :password_confirmation => 'foobar' }
      end
      it 'should create a user' do
        lambda do
          post :create, :user => @attr
        end.should change(User, :count).by(1)
      end
      it 'should redirect to the user show page' do
        post :create, :user => @attr
        response.should redirect_to( user_path(assigns(:user)) )
      end
    end
<<<<  RED (2)
vi users_controller.rb    >>> alterando a create action
    if @user.save
      redirect_to @user
<<<  GREEN
vi application.html.erb  >>>  Acrescentando as msgs flash
    <%= render 'layouts/header' %>
    <section class="round">
      <%= flash.each do |key, value| %>
        <div class="flash <%= key %>"><%= value %></div>
      <% end %>
<<<
vi users_controller_spec.rb    >>>  Testando a flash message on successful user signup.
      it 'should have a welcome message'do
        post :create, :user => @attr
        flash[:success].should =~ /welcome to the sample app/i
      end
<<<  RED
vi users_controller.rb    >>>  adicionando a flash message to ao user signup
    if @user.save
      flash[:success] = 'Welcome to the Sample App!'
<<<   GREEN

>>>>   8.4 RSpec integration tests
rails generate integration_test users

vi users_spec.rb   >>>>   Testing signup failure
describe "Users" do
  describe 'signup' do
    describe 'failure' do
      it 'should not make a new user' do
        lambda do
          visit signup_path
          fill_in 'Name',         :with => ''
          fill_in 'Email',        :with => ''
          fill_in 'Password',     :with => ''
          fill_in 'Confirmation', :with => ''
          click_button
          response.should render_template('users/new')
          response.should have_selector('div#error_explanation')
        end.should_not change(User, :count)
      end
    end
  end
<<<<   GREEN



*****===> 2011/08/07

vi users_spec.rb   >>>>  Testing signup success
    describe 'success' do
      it 'should make a new user' do
        lambda do
          visit signup_path
          fill_in "Name",         :with => 'Example User'
          fill_in "Email",        :with => 'user@example.com'
          fill_in "Password",     :with => 'foobar'
          fill_in "Confirmation", :with => 'foobar'
          click_button
          response.should have_selector('div.flash.success', :content => 'Welcome')
          response.should render_template('users/show')
        end.should change(User, :count).by(1)
      end
<<<<   GREEN

git add .
git commit -m 'User signup complete'
git checkout master
git merge signing-up





