Retirado de: Ruby on Rails Tutorial - Learn Rails by Example

rails new demo_app
cd demo_app

vi Gemfile  >>>>>
gem 'rails', '3.0.9'
gem 'sqlite3', '1.3.3'
<<<<<
bundle install

git init
git add .
git commit -m "Initial commit"

GitHub  >>>>>
Criei um novo repositório.
<<<<<
git config --global user.name "Fabio Lima"
git config --global user.mail fabionl@gmail.com
touch README 
git remote add origin git@github.com:fabionl/demo_app.git
git push -u origin master
>>>>>>>>
No meu caso deu problema e tive de seguir a orientação no github para configurar o ssh.
<<<<<<<<<

rails generate scaffold User name:string email:string
bundle exec rake db:migrate    >>>>>>
Testei a versão rake utilizado pelo bundle e o padrao do sistema e eram iguais.
a partir de agora, passo a usar o rake diretamente.
<<<<<
rails s
Browser: localhost:3000  >>>>>>
Abriu a página inicial do Rails.
<<<<<<<
rake -T db    >>>>>
Comando do db disponíveis.
<<<<<
rake -T    >>>>>>
Comandos disponíveis.
<<<<<

>>>>>>>
Criei alguns users.
<<<<<<<

rails generate scaffold Micropost content:string user_id:integer
rake db:migrate

>>>>>>>
Fazendo as alterações aos models.
<<<<<<<

git add .
git commit -a -m "Done with the demo app"
git push



****************************************************************************
****************************************************************************
****************************************************************************

*****===> 2011/08/02

rails new sample_app -T       >>>>>>>>  -T serve para não gerar o test directory
cd sample_app

vi Gemfile     >>>>>>>>
gem 'sqlite3', '1.3.3'

group :development do
  gem 'rspec-rails', '2.6.1'
end

group :test do
  gem 'rspec-rails', '2.6.1'
  gem 'webrat', '0.7.1'
end
<<<<<<<<<
bundle install
rails generate rspec:install

git init
git add .
git commit -m "Initial commit"

vi README   >>>>>>>>>>
    Substituição do Texto para uma descrição do Aplicativo, usando markdown.
<<<<<<<<
git mv README README.markdown
git commit -a -m "Improved the README"

git remote add origin git@github.com:fabionl/sample_app.git
git push origin master

git checkout -b static-pages    >>>>>> Criando um novo Topic Branch. A partir daqui o git tá focando nesse Topic Branch

rails generate controller Pages home contact
browser localhost:3000/pages/home    >>>>>>>>>
Apresentou uma página "place holder" da view.
<<<<<<<<<

git add .
git commit -m "Added a Pages controller"



*****===> 2011/08/03

vi Gemfile  >>>>>>>> Tentando autotest.
group :development, :test do
  gem 'autotest', '>= 4.4.6'
  gem 'autotest-rails-pure', '>= 4.1.2'
end
<<<<<<<<<<<<<
bundle install

vi Gemfile  >>>>>>>> Tentando autotest.
group :development, :test do
  # Especifico para o MacOSX
  gem 'autotest-fsevent', '>= 0.2.4'
  gem 'autotest-growl', '>= 0.2.9'
end
<<<<<<<<<<<<<
bundle install

vi .autotest     >>>>>>>>
require 'autotest-growl'
require 'autotest-fsevent'
<<<<<<<<<
git rm -r spec/views
git rm -r spec/helpers

rspec spec/     >>>>>  Executando os testes:
Pode-se usar outras opções:
rspec spec/controllers
rspec spec/controllers/pages_controller_spec.rb
<<<<<
autotest >>>>>>>>>>>>
No meu caso, deu uma mensagem de erro.
Rodei:
gem update --system

Isso resolveu o problema.
<<<<<<<<<<<<

vi Gemfile    >>>>>>>>  Instalando o Spork agora (aumentando velocidade dos testes)
group :test do
  gem 'spork', '>= 0.9.0.rc8'
end
<<<<<<<<
bundle exec spork --bootstrap
vi spec/spec_helper.rb    >>>>>>>>>>
Copiei todo o conteúdo do final do arquivo para dentro de:
Spork.prefork
<<<<<<<<<

time rspec spec/         >>>>>>>
Medidas de Tempo sem o Spork
<<<<<<
bundle exec spork
time rspec --drb spec/   >>>>>>>
Muito mais rápido agora. Tudo funcionando.
<<<<<<
vi .rspec    >>>>>>>>  Fazendo o rspec usar o spork by default.
--color
--drb
<<<<<<<<<
time rspec spec/    >>>>>>>  Funcionando!

>>>>> Agora mantenho 2 janelas terminal abertas, uma com spork e outra com autotest.


>>>>>>>>>  Fazendo um test que vai falhar.
vi spec/controllers/pages_controller_spec.rb    >>>>>>>>>
# O render_views, faz testar as views e não só os controllers.
describe PagesController do
  render_views

  describe "GET 'about'" do
    it "should be successful" do
      get 'about'
      response.should be_success
    end
  end
end
<<<<<<
>>>>>>>>>>>>>  OBS:
Importante notar que ao modificar views, precisa-se 'tocar' no controller para causar o autotest.
É preciso abrir o arquivo do controller e salvá-lo novamente.
<<<<<<<<<<<<<

>>>
Editei page_controller.rb para incluir def about.
Editei routes.rb para incluir get "pages/about"
Editei about.html.erb para incluir uma view simples.
<<<
Browser localhost:3000/pages/about

>>>>>>>>>>>>>>>>>>> Alterando os Titulos

>>>>
Page      URL             Base Title   Variable Title
=======================================================
Home     /pages/home      Sample App      | Home
Contact  /pages/contact   Sample App      | Contact
About    /pages/about     Sample App      | About
<<<<

vi pages_controler_spec.rb
vi application.html.erb

git add .     >>>>>>> Tudo ok. Git neles
git commit -m "Done with static pages"

git checkout master              >>> Mudando para o master branch
git merge static-pages           >>> Fazendo o merge do static-pages para o master branch
git push                         >>> Manda pro GitHub

>>>>>>> Copiei o blueprint CSS/blueprint/ para o public/stylesheets



***** Chapter 5 agora - Trabalhando no Layout

git checkout -b filling-in-layout     >>>> Criando um branch

>>>> Acrescentei uma estrutura básica no html do layout
>>>> Acrescentei os css's e passei parte da estrutura para partials.

>>>>> Hora dos Integration Tests  (requests specs)
rails generate integration_test layout_links

>>>> Escrevi os integrations tests no arquivo geram, apareceram os erros.
vi spec/requests/layout_links_spec.rb  >>>>>>>>>>> Um Exemplo:
  it "should have a Home page at '/'" do
    get '/'
    response.should have_selector('title', :content => 'Home')
  end
<<<<<<<<

>>> O tutotial indica o que fazer caso o autotest não execute os Integration Tests, no meu caso funcionou.

vi routes.rb  >>>>>>>>>>>>>
  match '/contact', :to => 'pages#contact'
  match '/about',   :to => 'pages#about'
  match '/help',    :to => 'pages#help'
  
  root :to => 'pages#home'
<<<<<<<<<<<

git rm public/index.html
git commit -m "Removed default Rails page"

>>>>>> Alterei os links nos layouts (header, footer, etc). Usando sempre o link_to e apontando para os atalhos criados (contact_path, about_path, root_path, etc)

>>>> Criando o Sign up
rails generate controller Users new
rm -rf spec/views
rm -rf spec/helpers

vi users_controller_spec.rb



*****===> 2011/08/04

>>> Criando o Signup.
vi users_controller_spec.rb >>>>>>>>> Criando o Spec do Signup
	it "should have the right title" do
	  get 'new'
	  response.should have_selector("title", :content => "Sign up")
	end
<<<<<<<<  RED
vi users_controller.rb  >>>>>>>>
  def new
    @title = "Sign up"
  end
<<<<<<<<  GREEN
vi layout_links_spec.rb   >>>>>>>> Criando o Integration Test
describe "LayoutLinks" do
  it "should have a signup page at '/signup'" do
    get '/signup'
    response.should have_selector('title', :content => "Sign up")
  end
end
<<<<<<<  RED
vi routes.rb     >>>>>>>>>>   Acrescentando a rota para o signup
  match '/signup',  :to => 'users#new'
<<<<<<<<<<  GREEN
vi pages/home.html.erb    >>>>>> Adicionando o link para o signup.
<%= link_to "Sign up now!", signup_path, :class => "signup_button round" %>
<<<<<<<<<<
>>>>>>>> Fazendo o commit e o merge no git.
rspec spec/          >>>>  GREEN
git add .
git commit -m "Finished layout and routes"
git checkout master
git merge filling-in-layout
git push       >>>> GitHub

git checkout -b exercises_5_5    >>>>>>>  Criando um Branch para os Exerc√≠cios (5.5) do tutorial

vi _header.html.erb     >>>>>  tirei a defini√ß√£o da logo (img)
vi application_helper.rb   >>>>>>
  def logo
    image_tag("logo.png", :alt => "Sample App", :class => "round")
  end
<<<<<
vi layout_links_spec.rb    >>>>>> Tests dos links.
  it "should have the right links on the layout" do
    visit root_path
    click_link "About"
    response.should have_selector('title', :content => "About")
    click_link "Help"
    response.should have_selector('title', :content => "Help")
    click_link "Contact"
    response.should have_selector('title', :content => "Contact")
    click_link "Home"
    response.should have_selector('title', :content => "Home")
    click_link "Sign up now!"
    response.should have_selector('title', :content => "Sign up")
  end
<<<<<<<   GREEN

rspec spec/     >>>> GREEN
git add .
git commit -m "Terminados os Exercicios (5.5) do tutorial. criando helper pra logo e testando os links das p√°ginas"
git checkout master
git merge exercises_5_5
git push     >>>> GitHub


>>>>>>>  Capitulo 6. - Modeling and viewing users, part I
git checkout master
git checkout -b modeling-users    >>> Criando o Branch

rails generate model User name:string email:string
rake db:migrate

vi Gemfile    >>>>>>  Adicionando o GEM Annotate -> Annotates Models
group :development do
  gem 'annotate', '>= 2.4.0'
end
<<<<<<
bundle install

>>>>>  No meu caso, o comando 'annotate' deu um problema. rodei 'gem update' (sem --system), mas nao funcionou, vou ficar com o comando do tutorial mesmo, por enquanto.
bundle exec annotate --position before     >>> Executando o annotate.

vi user.rb    >>>>>>  Definindo os atributos acess√≠veis ao usu√°rio.
  attr_accessible :name, :email
<<<<<

bundle exec rake db:test:prepare     >>>> Garantindo que o db de test está atualizado.

vi user.rb    >>> Escrevendo o validation 
  # validates :name, :presence => true
<<<
vi user_spec.rb   >>> Escrevendo o test para a validação, deixando o test do name como pending
describe User do
  #pending "add some examples to (or delete) #{__FILE__}"
  
  before(:each) do
    @attr = { :name => 'Example User', :email => 'user@example.com' }
  end

  it "should create a new instance given valid attributes" do
    User.create!(@attr)
  end

  it "should require a name"

end
<<<  1 PENDING

vi user_spec.rb    >>>> Escrevendo o test da validação agora.
  it "should require a name" do
    no_name_user = User.new( @attr.merge(:name => '') )
    no_name_user.should_not be_valid
  end
<<<<<   RED

vi user_spec.rb   >>>> Escrevi um test equivalente para o email.
vi user.rb   >>> Escrevendo a validação
   validates :name, :presence => true
   validates :email, :presence => true
<<<   GREEN

vi user_spec.rb  >>>> Test de validação do tamanho do nome
  it "should reject names that are too long" do
    long_name = 'a' * 51
    long_name_user = User.new( @attr.merge(:name => long_name) )
    long_name_user.should_not be_valid
  end
<<<<  RED
vi user.rb  >>>> Fiz a validação do tamanho do campo
<<<<  GREEN
vi user_spec.rb  >>>> Fiz o Teste da validação do email
<<<<  RED
vi user.rb  >>>> Fiz a validação do email
<<<<  GREEN
>>>>  Fiz os teste para garantir uniqueness no email. (case sensitive - 2 testes)
<<< RED
>>>>  Fiz a validação de uniqueness do email.
<<< GREEN



*****===> 2011/08/05

>>>>>  Alterando o DB para garantir o Uniqueness
rails generate migration add_email_uniqueness_index
rake db:migrate

vi application_html.erb    >>>> Incluindo Informações de Debug no Layout
    <%= debug(params) if Rails.env.development? %>
<<<<
>>>>>>>>>  Inclui um cliente de exemplo.
vi users_controller.rb   >>>>>>  Incluindo o metodo show.
  def show
    @user = User.find( params[:id] )
  end
<<<<<<<
vi show.html.erb       >>>>>>  Incluindo a view para mostrar o cliente.
<<<<<
vi routes.rb      >>>>>>   Acrescentando REST para users.
  resources :users   #> Retirar get 'users/new'
<<<<<<

git add .
git commit -m "Finished first cut of the User model"

>>>>>>>>>>>>  Chapter 7 - Modeling and viewuing users, part II
*** ATENÇÃO: Section 13.3 fala sobre o authentication que está sendo introduzido pelo Rails 3.1. (has_secure_password)

rake db:reset    >>> Resetando o db, removendo os registros temporarios.

vi user_spec.rb     >>>>>  Fazendo os tests para o password.
  before(:each) do
    @attr = {
      :name  => 'Example User',
      :email => 'user@example.com',
      :password => 'foobar',
      :password_confirmation => 'foobar'
    }
  end

  describe 'password validations' do
    it 'should require a password' do
      User.new( @attr.merge(:password => '', :password_confirmation => '') ).should_not be_valid
    end
    it 'should require a matching password confirmation' do
      User.new( @attr.merge(:password_confirmation => 'invalid') ).should_not be_valid
    end
    it 'should reject short passwords' do
      short = 'a' * 5
      hash = @attr.merge( :password => short, :password_confirmation => short )
      User.new(hash).should_not be_valid
    end
    it 'should reject long passwords' do
      long = 'a' * 41
      hash = @attr.merge( :password => short, :password_confirmation => short )
      User.new(hash).should_not be_valid
    end
  end
<<<<<<   RED (4)
vi user.rb        >>>>  Incluindo attributos virtuais e uma validação para o password (password_confirmation)
  attr_accessor :password
  attr_accessible :name, :email, :password, :password_confirmation

  validates :password, :presence     => true,
                       :confirmation => true,
                       :length       => { :within => 6..40 }
<<<<  GREEN
vi user_spec     >>>> Testando o campo encrypted_password
  describe 'password encryption' do
    before(:each) do
      @user = User.create!( @attr )
    end
    it 'should have an encrypted password attribute' do
      @user.should respond_to(:encrypted_password)
    end
  end
<<<<   RED

rails generate migration add_password_to_users encrypted_password:string   >>> Gerando o campo encrypted_password
rake db:migrate
rake db:test:prepare

rspec spec/models/user_spec.rb -e 'should have an encrypted password attribute'  >>> Executa o teste específico do campo encrypted_password
<<<<<  GREEN

vi user_spec.rb      >>> Testando se encrypted password não aceita blank.
  describe 'password encryption' do
    it 'should set the encrypted password' do
      @user.encrypted_password.should_not be_blank
    end
<<<   RED
vi user.rb    >>> Adicionando um callback para salvar o encrypted_password
  before_save :encrypt_password
  private
    def encrypt_password
      self.encrypted_password = encrypt(password)
    end
    def encrypt(string)
      string   # Only a temporary implementation!
    end
<<<    GREEN

vi user.rb   >>>> Adicionando um metodo para comparar os passwords
  def has_password?(submitted_password)
    # Compare encrypted_password with the encrypted version of submitted_password.
  end
<<<<
vi user_spec.rb     >>> Testando se has_password? retorna true ou false.
  describe 'password encryption' do
    describe 'has_password? method' do
      it 'should be true if the passwords match' do
        @user.has_password?( @attr[:password] ).should be_true
      end
      it 'should be false if the passwords dont match' do
        @user.has_password?( 'invalid' ).should be_false
      end
    end
<<<    RED

>>>> Gerando o campo salt
rails generate migration add_salt_to_users salt:string
rake db:migrate
rake db:test:prepare
<<<<
vi user.rb    >>>>> Implementando has_password?
require 'digest'   # Para uso da criptografia. (SHA2)

  def has_password?(submitted_password)
    encrypted_password == encrypt( submitted_password )
  end

  private
    def encrypt_password
      self.salt = make_salt if new_record?
      self.encrypted_password = encrypt(password)
    end
    def encrypt(string)
      secure_hash( "#{salt}--#{string}" )   # Only a temporary implementation!
    end
    def make_salt
      secure_hash( "#{Time.now.utc}--#{password}" )
    end
    def secure_hash(string)
      Digest::SHA2.hexdigest(string)
    end
<<<<<   GREEN
rails console --sandbox    >>> Roda o console sem salvar alterações no DB
<<<<< Foi usado só pra testar o caso de uso.

vi user_spec     >>> Escrevendo o teste para o User.authenticate(email, submitted_password)
  describe 'password encryption' do
    describe 'authenticate method' do
      it 'should return nil on email/password mismatch' do
        wrong_password_user = User.authenticate( @attr[:email], 'wrongpass')
        wrong_password_user.should be_nil
      end
      it 'should return nil for an email with no user' do
        nonexistent_user = User.authenticate( 'bar@foo.com', @attr[:password] )
        nonexistent_user.should be_nil
      end
      it 'should return user on email/password match' do
        matching_user = User.authenticate( @attr[:email], @attr[:password] )
        matching_user.should == @user
      end
    end
<<<<<<   RED (3)
vi user.rb   >>>>  Criando o método authenticate. OBS: self é usado para criar como class method.
  def self.authenticate(email, submitted_password)
    user = find_by_email(email)
    return nil if user.nil?
    return user if user.has_password?(submitted_password)
  end
<<<<  GREEN

vi Gemfile   >>>> Adicionando gem factory Girl para os tests
group :test do
  gem 'factory_girl_rails', '1.0'
<<<<
bundle install

vi factories.rb    >>>>> Populando db de teste
Factory.define :user do |user|
  user.name                   'Michael Hartl'
  user.email                  'mhartl@example.com'
  user.password               'foobar'
  user.password_confirmation  'foobar'
end
<<<<<

vi users_controller_spec.rb   >>>>> Usando a factory para os testes.
  describe "GET 'show'" do
    before(:each) do
      @user = Factory(:user)
    end
    it 'should be successful' do
      get :show, :id => @user
      response.should be_success
    end
    it 'should find the right user' do
      get :show, :id => @user
      assigns(:user).should == @user
    end
  end
<<<<<    GREEN

>>>>>>>>> Melhorando a view Show
rake db:reset
User.create!(:name => 'Example User', :email => 'user@example.com', :password => 'foobar', :password_confirmation => 'foobar')

vi users_controller_spec.rb    >>>>>   Checando os elementos da página.
  describe "GET 'show'" do
    it 'should have the right title' do
      get :show, :id => @user
      response.should have_selector('title', :content => @user.name)
    end
    it "should include the user's name" do
      get :show, :id => @user
      response.should have_selector('h1', :content => @user.name)
    end
    it 'should have a profile image' do
      get :show, :id => @user
      response.should have_selector('h1>img', :class=> 'gravatar')
    end
<<<<<   RED (3)
vi users_controller.rb    >>>>  Definindo o @title no method show
  def show
    @user = User.find( params[:id] )
    @title = @user.name
  end
<<<<   RED (2)
vi show.html.erb    >>>>>
<h1>
  <%= @user.name %>
</h1>
<<<<<   RED

vi Gemfile   >>>> adicionando a gem gravatar_image_tag para utilizar o Gravatar
gem 'gravatar_image_tag', '>= 1.0.0.pre2'
<<<<
bundle install

vi users_helper.rb     >>> helper pro gravatar
  def gravatar_for( user, options = { :size => 50} )
    gravatar_image_tag( user.email.downcase, :alt => user.name,
                                             :class => 'gravatar',
                                             :gravatar => options)
  end
<<<
vi show.html.erb    >>>>  Incluindo o gravatar na view
<h1>
  <%= gravatar_for @user %>
  <%= @user.name %>
</h1>
<<<<    GREEN

vi show.html.erb    >>>>  Adding a sidebar to the user show view
<table class='profile' summary='Profile information'>
  <tr>
    <td class='main'>
	  <h1>
		<%= gravatar_for @user %>
		<%= @user.name %>
	  </h1>
    </td>
    <td class='sidebar round'>
      <strong>Name</strong> <%= @user.name %><br/>
      <strong>URL</strong> <%= link_to user_path( @user ), @user %>
    </td>
  </tr>
</table>
<<<<
vi custom.css    >>>> CSS styling the user show page

git branch     >>> Verificando se estamos no branch correto.
git add .
git commit -m "User model with passwords, and user show page"
git checkout master
git merge modeling-users
git push     >>> GitHub


>>>>>>>>> Capitulo 8 - Sign up

bundle exec rake db:reset     >>> ou 'rake db:reset'   tanto faz.

git checkout master
git checkout -b signing-up

vi new.html.erb     >>>  Criando o form de signup
  .
  .
  .
  # Tudo normal até esses 2 campos.
  <div class='field'>
    <%= f.label :password %><br/>
    <%= f.password_field :password %>
  </div>
  <div class='field'>
    <%= f.label :password_confirmation, 'Confirmation' %><br/>
    <%= f.password_field :password_confirmation %>
  </div>
  .
  .
  .
<<<
vi users_controller.rb    >>>> Adicionando @user à action new
  def new
    @user = User.new
<<<
vi custom.css     >>>   Styling o Form
div.field, div.actions {
  margin-bottom: 10px;
}
<<<<
vi users_controller_spec.rb     >>>>>
  describe "POST 'create'" do
    describe 'failure' do
      before(:each) do
        @attr = { :name => '', :email => '', :password => '', :password_confirmation => '' }
      end
      it 'should not create a user' do
        lambda do
          post :create, :user => @attr
        end.should_not change(User, :count)
      end
      it 'should have the right title' do
        post :create, :user => @attr
        response.should have_selector('title', :content => 'Sign up')
      end
      it "should render the 'new' page" do
        post :create, :user => @attr
        response.should render_template('new')
      end
    end
  end
<<<<  RED (3)
vi users_controller.rb    >>> Acrescentando o metodo create   def create
    @user = User.new( params[:user] )
    if @user.save
      # Handle a successful save.
    else
      @title = 'Sign up'
      render 'new'
    end
  end
<<<  GREEN
vi new.html.erb   >>> Acrescentando os erros ao form
<%= form_for(@user) do |f| %>
  <%= render 'shared/error_messages' %>
<<<
vi shared/_error_messages.html.erb   >>> Partial para mostrar os error messages
<% if @user.errors.any? %>
  <div id='error_explanation'>
    <h2><%= pluralize(@user.errors.count, 'error') %> prohibited this user from being saved:</h2>
    <p>There were problems with the following fields:</p>
    <ul>
    <% @user.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
<% end %>
<<<



*****===> 2011/08/06

vi custom.css   >>> Styling as error messages

>>>>  OBS: em config/application.rb, pode-se usar config.fileter_parameters += [:password, etc] para filtrar dados que não devem ser copiados para os logs. Exemplo, nesse caso, são os campos :password.
<<<<

vi users_controller_spec.rb   >>>> Tests for signup success
    describe 'success' do
      before(:each) do
        @attr = { :name => 'New User', :email => 'user@example.com',
                  :password => 'foobar', :password_confirmation => 'foobar' }
      end
      it 'should create a user' do
        lambda do
          post :create, :user => @attr
        end.should change(User, :count).by(1)
      end
      it 'should redirect to the user show page' do
        post :create, :user => @attr
        response.should redirect_to( user_path(assigns(:user)) )
      end
    end
<<<<  RED (2)
vi users_controller.rb    >>> alterando a create action
    if @user.save
      redirect_to @user
<<<  GREEN
vi application.html.erb  >>>  Acrescentando as msgs flash
    <%= render 'layouts/header' %>
    <section class="round">
      <%= flash.each do |key, value| %>
        <div class="flash <%= key %>"><%= value %></div>
      <% end %>
<<<
vi users_controller_spec.rb    >>>  Testando a flash message on successful user signup.
      it 'should have a welcome message'do
        post :create, :user => @attr
        flash[:success].should =~ /welcome to the sample app/i
      end
<<<  RED
vi users_controller.rb    >>>  adicionando a flash message to ao user signup
    if @user.save
      flash[:success] = 'Welcome to the Sample App!'
<<<   GREEN

>>>>   8.4 RSpec integration tests
rails generate integration_test users

vi users_spec.rb   >>>>   Testing signup failure
describe "Users" do
  describe 'signup' do
    describe 'failure' do
      it 'should not make a new user' do
        lambda do
          visit signup_path
          fill_in 'Name',         :with => ''
          fill_in 'Email',        :with => ''
          fill_in 'Password',     :with => ''
          fill_in 'Confirmation', :with => ''
          click_button
          response.should render_template('users/new')
          response.should have_selector('div#error_explanation')
        end.should_not change(User, :count)
      end
    end
  end
<<<<   GREEN



*****===> 2011/08/07

vi users_spec.rb   >>>>  Testing signup success
    describe 'success' do
      it 'should make a new user' do
        lambda do
          visit signup_path
          fill_in "Name",         :with => 'Example User'
          fill_in "Email",        :with => 'user@example.com'
          fill_in "Password",     :with => 'foobar'
          fill_in "Confirmation", :with => 'foobar'
          click_button
          response.should have_selector('div.flash.success', :content => 'Welcome')
          response.should render_template('users/show')
        end.should change(User, :count).by(1)
      end
<<<<   GREEN

git add .
git commit -m 'User signup complete'
git checkout master
git merge signing-up


>>>>>>>>> Capitulo 9 - Sign in, sign out

git checkout -b sign-in-out   >>> Abrindo o branch para o capitulo.

rails generate controller Sessions new     >>> Criando o controller Sessions
rm -rf spec/views
rm -rf spec/helpers

vi sessions_controller_spec.rb    >>>  Tests the new session action and view.
describe SessionsController do
  render_views
   .
   .
   .
    it 'should have the right title' do
      get :new
      response.should have_selector( 'title', :content => 'Sign in' )
    end
  end
<<<   RED
vi routes.rb   >>>  Adicionando as rotas para o session
  resources :sessions, :only => [:new, :create, :destroy]
  match '/signin',  :to => 'sessions#new'
  match '/signout',  :to => 'sessions#destroy'
<<<  RED
vi sessions_controller.rb   >>>>    Adicionando o title ao signin page
  def new
    @title = 'Sign in'
  end
  def create
  end
  def destroy
  end
<<<<   GREEN
vi sessions/new.html.erb   >>>>  Adicionando o form pro signin
<h1>Sign in</h1>

<%= form_for( :session, :url => sessions_path ) do |f| %>
  <div class='field'>
    <%= f.label :email %> <br/>
    <%= f.text_field :email %>
  </div>
  <div class='field'>
    <%= f.label :password %> <br/>
    <%= f.password_field :password %>
  </div>
  <div class='actions'>
    <%= f.submit 'Sign in' %>
  </div>
<% end %>

<p>New user? <%= link_to 'Sign up now!', signup_path %></p>
<<<<
vi sessions_controller.rb   >>> Versao inicial do create action
  def create
    render 'new'
  end
<<<
vi session_controller_spec.rb   >>>> Tests for a failed signin attempt
  describe "POST 'create'" do
    describe 'invalid signin' do
      before(:each) do
        @attr = { :email => 'email@example.com', :password => 'invalid' }
      end
      it 'should re-render the new page' do
        post :create, :session => @attr
        response.should render_template('new')
      end
      it 'should have the right title' do
        post :create, :sesson => @attr
        response.should have_selector('title', :content => 'Sign in')
      end
      it 'should have a flash.now message' do
        post :create, :session => @attr
        flash.now[:error].should =~ /invalid/i
      end
    end
  end
<<<<  RED (2)
vi sessions_controller.rb    >>>   Code for failed signin attempt, and preparing the sign_in success
  def create
    user = User.authenticate( params[:session][:email],
                              params[:session][:password] )
    if user.nil?
      flash.now[:error] = 'Invalid email/password combination.'
      @title = 'Sign in'
      render 'new'
    else
      sign_in user
      redirect_to user
    end
  end
<<<   GREEN
vi session_controller_spec.rb  >>>  Pending tests for user signin
	describe 'with valid email and password' do
	  before(:each) do
		@user = Factory(:user)
		@attr = {:email => @user.email, :password => @user.password }
	  end
	  it 'should sign the user in' do
		post :create, :session => @attr
		# Fill in with tets for a signed-in user.
	  end
	  it 'should redirect to the user show page' do
		post :create, :session => @attr
		response.should redirect_to( user_path(@user) )
	  end
	end
<<<   RED (2)
vi application_controller.rb   >>>   Including the Sessions helper module into the application controller.
  include SessionsHelper
<<<
vi sessions_helper.rb    >>> Criando a função sign_in  (ainda não funciona)
  def sign_in(user)
    cookies.permanent.signed[:remember_token] = [user.id, user.salt]
    self.current_user = user
  end
<<<
vi sessions_controller_spec.rb    >>> Filling in the test for signing the user in.
	  it 'should sign the user in' do
		post :create, :session => @attr
		controller.current_user.should == @user
		controller.should be_signed_in
	  end
	  it 'should redirect to the user show page' do
		post :create, :session => @attr
		response.should redirect_to( user_path(@user) )
	  end
<<<   RED (2)    (continua igual ao anterior)
vi sessions_helper.rb      >>>>  Defining assignment to current_user. finding current user by remember_token
  def current_user=(user)
    @current_user = user
  end
  def current_user
    @current_user ||= user_from_remember_token
  end
  private
    def user_from_remember_token
      User.authenticate_with_salt(*remember_token)     # O mesmo que pegar o hash e usar cada item como variaveis para a função
    end
    def remember_token
      cookies.signed[:remember_token] || [nil, nil]
    end
<<<<
vi user.rb   >>>  Adding an autheticate_with_salt method to the User model.
  def self.authenticate_with_salt(id, cookie_salt)
    user = find_by_id(id)
    (user && user.salt == cookie_salt) ? user : nil
  end
<<<   RED (2)



*****===> 2011/08/08

vi sessions_help.rb    >>>   signed_in? helper method
  def signed_in?
    !current_user.nil?
  end
<<<   GREEN

>>>>>>>>>>>>>>>>> Signing Out

vi spec_helper.rb    >>>>  função test_sign_in para simular use signin dentro dos testes.
  RSpec.configure do |config|
    # Efetuando o signin dentro dos testes.
    def test_sign_in(user)
      controller.sign_in(user)
    end
  end
<<<<
vi sessions_controller_spec.rb   >>>   Testando o sign out
  describe "DELETE 'destroy'" do
    it 'should sign a user out' do
      test_sign_in( Factory(:user) )
      delete :destroy
      controller.should_not be_signed_in
      response.should redirect_to(root_path)
    end
  end
<<<    RED
vi sessions_controller.rb    >>>  Destroying a sessions (user signout)
  def destroy
    sign_out
    redirect_to root_path
  end
<<<
vi sessions_helper.rb     >>> The sign_out method in the Sessions helper module.
  def sign_out
    cookies.delete(:remember_token)
    self.current_user = nil
  end
<<<   GREEN
vi users_controller_spec.rb   >>> Testing the newly signed-up users are also signed in.
    describe 'success' do
      it 'should sign the user in' do
        post :create, :user => @attr
        controller.should be_signed_in
      end
<<<   RED
vi users_controller.rb    >>>  Signing in the user upon signup.
    if @user.save
      sign_in @user
<<<    GREEN

vi layout_links_spec.rb    >>>  Tests for the signin/signout links on the site layout.
  describe "when not signed in" do
    it 'should have a signin link' do
      visit root_path
      response.should have_selector('a', :href => signin_path, :content => 'Sign in')
    end
  end
  describe 'whem signed in' do
    before(:each) do
      @user = Factory(:user)
      visit signin_path
      fill_in :email,    :with => @user.email
      fill_in :password, :with => @user.password
      click_button
    end
    it 'should have a signout link' do
      visit root_path
      response.should have_selector('a', :href => signout_path, :content => 'Sign out')
    end
    it 'should have a profile link'
  end
<<<   RED (2) , Pending (1)
vi _header.html.erb      >>>  Changing the layout links for signed-in users.
	  <% if signed_in? %>
        <li><%= link_to 'Sign out', signout_path, :method => :delete %></li> 
      <% else %>
	    <li><%= link_to "Sign in", signin_path %></li>
	  <% end %>
<<<    Pending (1)
vi layout_links_spec.rb     >>>  A Test for a profile link.
    it 'should have a profile link' do
      visit root_path
      response.should have_selector('a', :href => user_path(@user), :content => 'Profile')
    end
<<<   RED
vi _header.html.erb     >>>> Adding a profile link.
	  <li><%= link_to "Home", root_path %></li>
	  <% if signed_in? %>
	    <li><%= link_to 'Profile', current_user %></li>
	  <% end %>
<<<<    GREEN
vi users_spec.rb   >>> An Integration test for sgning in and out.
  describe 'sign in/out' do
    describe 'failure' do
      it 'should not sign a user in' do
        visit signin_path
        fill_in :email,    :with => ''
        fill_in :password, :with => ''
        click_button
        response.should have_selector('div.flash.error', :content => 'Invalid')
      end
    end
    describe 'success' do
      it 'should sign a user in and out' do
        user = Factory(:user)
        visit signin_path
        fill_in :email,    :with => user.email
        fill_in :password, :with => user.password
        click_button
        controller.should be_signed_in
        click_link 'Sign out'
        controller.should_not be_signed_in
      end
    end
  end
<<<    GREEN

git add .
git commit -m 'Done with sign in'
git checkout master
git merge sign-in-out

>>>>>>> Fazendo um refactory to integration test

git checkout sign-in-out   >>> Mudando novamente o branch

vi spec_helper.rb    >>>  a function to sign users in inside of integration tests.
    def integration_sign_in(user)
      visit signin_path
      fill_in :email,    :with => user.email
      fill_in :password, :with => user.password
      click_button
    end
<<<
vi users_spec.rb   >>>>
        integration_sign_in(user)
        #visit signin_path
        #fill_in :email,    :with => user.email
        #fill_in :password, :with => user.password
        #click_button
<<<<
vi layout_links_spec   >>>
      integration_sign_in(@user)
      #visit signin_path
      #fill_in :email,    :with => @user.email
      #fill_in :password, :with => @user.password
      #click_button
<<<

git add .
git commit -m 'refactory do signin nos integration tests.'
git checkout master
git merge sign-in-out


>>>>>>>>> Capitulo 9 - Sign in, sign out


*****===> 2011/08/09

git checkout -b updating-users

vi users_controller_spec.rb    >>> Tests for the user edit action.
  describe "GET 'edit'" do
    before(:each) do
      @user = Factory(:user)
      test_sign_in(@user)
    end
    it 'should be successful' do
      get :edit, :id => @user
      response.should be_success
    end
    it 'should have the right title' do
      get :edit, :id => @user
      response.should have_selector('title', :content => 'Edit user')
    end
    it 'should have a link to change the Gravatar' do
      get :edit, :id => @user
      gravatar_url = 'http://gravatar.com/emails'
      response.should have_selector('a', :href => gravatar_url, :content => 'change')
    end
  end
<<<    RED (3)
vi users_controller.rb    >>>  The user edit action
  def edit
    @user = User.find( params[:id] )
    @title = 'Edit user'
  end
<<<
vi users/edit.html.erb    >>>  The user edit view.
  <h1>Edit user</h1>
  <%= form_for(@user) do |f| %>
	<%= render 'shared/error_messages', :object => f.object %>
	<div class='field'>
	  <%= f.label :name %><br/>
	  <%= f.text_field :name %>
	</div>
	.
	.
	.
	<div class='actions'>
	  <%= f.submit 'Update' %>
	</div>
  <% end %>
  <div>
	<%= gravatar_for @user %>
	<a href='http://gravatar.com/emails'>change</a>
  </div>
<<<    GREEN
vi shared/_error_messages.html.erb   >>> Updating the error-messages partial to work with other objs
<% if object.errors.any? %>
  <div id='error_explanation'>
    <h2><%= pluralize(object.errors.count, 'error') %>
        prohibited this <%= object.class.to_s.underscore.humanize.downcase %>
        from being saved:</h2>
    <p>There were problems with the following fields:</p>
    <ul>
    <% object.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
<% end %>
<<<   RED (9)
vi users/new.html.erb   >>> Updating the rendering of user signup erros.
<%= form_for(@user) do |f| %>
  <%= render 'shared/error_messages', :object => f.object %>
<<<   GREEN
vi layouts/_header.html.erb    >>> Adding a Settings link.
	    <li><%= link_to 'Profile', current_user %></li>
	    <li><%= link_to 'Settings', edit_user_path(current_user) %></li>
<<<

vi users_controller_spec.rb   >>>  Tests for the user update action.
  describe "PUT 'update'" do
    before(:each) do
      @user = Factory(:user)
      test_sign_in( @user )
    end
    describe 'failure' do
      before(:each) do
        @attr = { :email => '', :name => '', :password => '', :password_confirmation => '' }
      end
      it "should render the 'edit' page" do
        put :update, :id => @user, :user => @attr
        response.should render_template('edit')
      end
      it 'should have the right title' do
        put :update, :id => @user, :user => @attr
        response.should have_selector( 'title', :content => 'Edit user' )
      end
    end
    describe 'success' do
      before(:each) do
        @attr = { :name => 'New Name', :email => 'user@example.org',
                  :password => 'barbaz', :password_confirmation => 'barbaz' }
      end
      it "should change the user's attributes" do
        put :update, :id => @user, :user => @attr
        @user.reload
        @user.name.should == @attr[:name]
        @user.email.should == @attr[:email]
      end
      it "should redirect to the user show page" do
        put :update, :id => @user, :user => @attr
        response.should redirect_to( user_path(@user) )
      end
      it "should have a flash message" do
        put :update, :id => @user, :user => @attr
        flash[:success].should =~ /updated/
      end
    end
  end
<<<    RED (5)
vi users_controller.rb    >>>   The user update action
  def update
    @user = User.find( params[:id] )
    if @user.update_attributes( params[:user] )
      flash[:success] = 'Profile updated.'
      redirect_to @user
    else
      @title = 'Edit user'
      render 'edit'
    end
  end
<<<    GREEN


>>>>>>>>>>>>>>>>  10.2 Protecting Pages

vi users_controller_spec.rb     >>>  The first tests for authentication.
  describe 'authentication of edit/update pages' do
    before(:each) do
      @user = Factory(:user)
    end
    describe 'for non-signed-in users' do
      it "should deny access to 'edit'" do
        get :edit, :id => @user
        response.should redirect_to( signin_path )
      end
      it "should deny access to 'update'" do
        put :update, :id => @user, :user => {}
        response.should redirect_to( signin_path )
      end
    end
  end
<<<     RED (2)
vi users_controller.rb     >>>  Adding an authenticate before filter.
class UsersController < ApplicationController
  before_filter :authenticate, :only => [:edit, :update]
  private
    def authenticate
      deny_access unless signed_in?
    end
<<<     RED (2)
vi sessions_helper.rb      >>>  The deny_access method for user authentication.
  def deny_access
    redirect_to signin_path, :notice => 'Please sign in to access this page.'
  end
<<<    GREEN

vi users_controller_spec.rb    >>>  Authentication tests for signed-in users.
  describe 'authentication of edit/update pages' do
    describe 'for signed-in users' do
      before(:each) do
        wrong_user = Factory(:user, :email => 'user@example.net')
        test_sign_in( wrong_user )
      end
      it "should require matching users for 'edit'" do
        get :edit, :id => @user
        response.should redirect_to(root_path)
      end
      it "should require matching users for 'update'" do
        put :update, :id => @user, :user => {}
        response.should redirect_to(root_path)
      end
    end
<<<    RED (2)
vi users_controller.rb   >>>  A correct_user before filter to protect the edit/update pages.
  before_filter :authenticate, :only => [:edit, :update]
  before_filter :correct_user, :only => [:edit, :update]
  def edit
    @title = 'Edit user'
  end
  private
    def correct_user
      @user = User.find( params[:id] )
      redirect_to(root_path) unless current_user?(@user)
    end
<<<     RED (10)
vi sessions_helper.rb   >>>  the current_user? method
  def current_user?(user)
    user == current_user
  end
<<<     GREEN
vi users_controller.rb   >>> Remove (ou comenta) linha abaixo do update method
    @user = User.find( params[:id] )
<<<


>>>>>>>>>>  10.2.3 Friendly forwarding

rails generate integration_test friendly_forwarding    >>> Gerando o integratin_test.

vi requests/friendly_forwardings_spec.rb   >>>  An integration test for friendly forwarding
describe "FriendlyForwardings" do
  it 'should forward to the requested page after signin' do
    user = Factory(:user)
    visit edit_user_path(user)
    # The test automatically follows the redirect to the signin page.
    fill_in :email,    :with => user.email
    fill_in :password, :with => user.password
    click_button
    # The test follows the redirect again, this time to users/edit.
    response.should render_template('users/edit')
  end
<<<    RED (1)
vi sessions_helper.rb   >>>  Code to implement friendly forwarding.
  def deny_access
    store_location
    redirect_to signin_path, :notice => 'Please sign in to access this page.'
  end
  def redirect_back_or(default)
    redirect_to( session[:return_to] || default )
    clear_return_to
  end
  private
    def store_location
      session[:return_to] = request.fullpath
    end
    def clear_return_to
      session[:return_to] = nil
    end
<<<
vi sessions_controller.rb    >>>  The Sessions create action with friendly forwarding.
  def create
    else
      sign_in user
      redirect_back_or user
<<<    GREEN


>>>>>>>   10.3.1 User Index

vi users_controller_spec.rb     >>>  Tests for the user index page.
  describe "GET 'index'" do
    describe "for non-signed-in users" do
      it 'should deny access' do
        get :index
        response.should redirect_to(signin_path)
        flash[:notice].should =~ /sign in/i
      end
    end
    describe "for signed-in users" do
      before(:each) do
        @user = test_sign_in( Factory(:user) )
        second = Factory(:user, :name => 'Bob', :email => 'another@example.com')
        third  = Factory(:user, :name => 'Ben', :email => 'another@example.net')
        @users = [ @user, second, third ]
      end
      it 'should be successful' do
        get :index
        response.should be_success
      end
      it 'should have the right title' do
        get :index
        response.should have_selector('title', :content => 'All users')
      end
      it 'should have an element for each user' do
        get :index
        @users.each do |user|
          response.should have_selector('li', :content => user.name)
        end
      end
<<<     RED (4)
vi users_controller.rb    >>>  The user index action.
class UsersController < ApplicationController
  before_filter :authenticate, :only => [:index, :edit, :update]
  def index
    @title = 'All users'
    @users = User.all
  end
<<<    RED (3)
vi users/index.html.erb   >>>  The user index view.
<h1>All users</h1>
<ul class='users'>
  <% @users.each do |user| %>
    <li>
      <%= gravatar_for user, :size => 30 %>
      <%= link_to user.name, user %>
    </li>
  <% end %>
</ul>
<<<     GREEN
vi custom.css    >>>  CSS for the user index.
ul.users { margin-top: 1em; }
.users li { list-style: none; }
<<<
vi layouts/_header.html.erb   >>>>  A layout link to the user index.
<<<<


>>>>>>>>>>>>  10.3.2 Sample users

vi Gemfile   >>>> Adding the Faker gem.
group :development do
  gem 'faker', '>= 0.3.1'
<<<<
bundle install

vi lib/tasks/sample_data.rake   >>>  A Rake task for populating the database with sample users.
namespace :db do
  desc 'Fill database with sample data'
  task :populate => :environment do
    Rake::Task['db:reset'].invoke
    User.create!(:name => 'Example User',
                 :email => 'example@railstutorial.org',
                 :password => 'foobar',
                 :password_confirmation => 'foobar')
    99.times do |n|
      name = Faker::Name.name
      email = "example-#{n+1}@railstutorial.org"
      password = 'password'
      User.create!(:name => name,
                   :email => email,
                   :password => password,
                   :password_confirmation => password)
    end
  end
end
<<<
rake db:populate

>>>>>>> 10.3.3 Pagination

vi Gemfile    >>>>  Including will_paginate in the Gemfile
gem 'gravatar_image_tag', '>= 1.0.0.pre2'
gem 'will_paginate', '>= 3.0.pre2'
<<<<
bundle install

vi users/index.html.erb   >>>  The user index with pagination
<h1>All users</h1>
<%= will_paginate %>
  .
  .
  .
</ul>
<%= will_paginate %>
<<<
vi users_controller.rb   >>>>  Paginating the users in the index action.
  def index
    @title = 'All users'
    #@users = User.all
    @users = User.paginate( :page => params[:page] )
  end
<<<<    Pagination tá funcionando.

>>>>>> Testing Pagination

vi spec/factories.rb   >>> Defining a Factory Girl sequence.
Factory.sequence :email do |n|
  "person-#{n}@example.com"
end<<<
vi users_controller_spec.rb   >>>  A test for pagination
  describe "GET 'index'" do
    describe "for signed-in users" do
      before(:each) do
        .
        .
        .
        @users = [ @user, second, third ]
        30.times do
          @users << Factory( :user, :email => Factory.next(:email) )
        end
      it 'should have an element for each user' do
        get :index
        @users[0..2].each do |user|
          response.should have_selector('li', :content => user.name)
        end
      end
      it 'should paginate users' do
        get :index
        response.should have_selector('div.pagination')
        response.should have_selector('span.disabled', :content => 'Previous')
        response.should have_selector('a', :href => '/users?page=2',
                                           :content => '2')
        response.should have_selector('a', :href => '/users?page=2',
                                           :content => 'Next')
      end
<<<    GREEN

vi users/index.html.erb     >>>  The first Refactoring attempt at the index view.
  <% @users.each do |user| %>
    <%= render user %>
  <% end %>
<<<    RED (4)
vi users/_user.html.erb   >>>  A Partial to render a single user
    <li>
      <%= gravatar_for user, :size => 30 %>
      <%= link_to user.name, user %>
    </li>
<<<   GREEN
vi users/index.html.erb   >>> The fully refactored user index.
<ul class='users'>
  <%= render @users %>
</ul>
<<<    GREEN


>>>>>>>>>>>>  10.4 Destroying users

>>>>>> 10.4.1 Administrative users

vi user_spec.rb   >>>  Tests for an admin attribute
  describe 'admin attribute' do
    before(:each) do
      @user = User.create!(@attr)
    end
    it 'should respond to admin' do
      @user.should respond_to(:admin)
    end
    it 'should not be an admin by default' do
      @user.should_not be_admin
    end
    it 'should be convertible to an admin' do
      @user.toggle!(:admin)
      @user.should be_admin
    end
  end
<<<    RED (3)
rails generate migration add_admin_to_users admin:boolean
vi db/migrate/<timestamp>_add_admin_to_users.rb    >>> Alterando o migration para incluir o default
  def self.up
    add_column :users, :admin, :boolean, :default => false
  end
<<<
rake db:migrate
rake db:test:prepare

vi lib/tasks/sample_data.rake      >>>  The sample data populator code with an admin user.
    admin = User.create!(:name => 'Example User',
                 :email => 'example@railstutorial.org',
                 :password => 'foobar',
                 :password_confirmation => 'foobar')
    admin.toggle!(:admin)
<<<    GREEN
rake db:populate

>>>>>>  OBS: pag. 291, tem uma observação importante sobre attr_accessible. Não colocando :admin em attr_accessble, torna-se impossivel fazer algo como 'put /users/1?admin=1', o que aumenta a segurança. Torna-se necessário usar algo como o metodo toggle! acima.

vi users/_user.html.erb   >>>  User delete links (viewable only by admins)
  <% if current_user.admin? %>
  | <%= link_to 'delete', user, :method => :delete, :confirm => 'You sure?',
                                :title => "Delete #{user.name}" %>
  <% end %>
<<<
vi application.html.erb    >>>  Adding the default JavaScript librearies to the sample app.
<head>
  <%= javascript_include_tag :defaults %>
<<<    Obs: Importante security role, só pode ser permitido deletar por admins.
vi users_controller_spec.rb    >>> Tests for destroying users.
  describe "DELETE 'destroy'" do
    before(:each) do
      @user = Factory(:user)
    end
    describe 'as a non-signed-in user' do
      it 'should deny access' do
        delete :destroy, :id => @user
        response.should redirect_to(signin_path)
      end
    end
    describe 'as a non-admin user' do
      it 'should protect the page' do
        test_sign_in(@user)
        delete :destroy, :id => @user
        response.should redirect_to(root_path)
      end
    end
    describe 'as an admin user' do
      before(:each) do
        admin = Factory( :user, :email => 'admin@example.com', :admin => true)
        test_sign_in(admin)
      end
      it 'should destroy the user' do
        lambda do
          delete :destroy, :id => @user
        end.should change(User, :count).by(-1)
      end
      it 'should redirect to the users page' do
        delete :destroy, :id => @user
        response.should redirect_to(users_path)
      end
    end
  end
<<<   RED (4)
vi users_controller.rb   >>>  A before_filter restricting the destroy action to admins.
class UsersController < ApplicationController
  before_filter :authenticate, :only => [:index, :edit, :update, :destroy]
  before_filter :correct_user, :only => [:edit, :update]
  before_filter :admin_user,   :only => [:destroy]
  .
  .
  .
  def destroy
    User.find(params[:id]).destroy
    flash[:success] = 'User destroyed.'
    redirect_to users_path
  end
  private
    def admin_user
      redirect_to(root_path) unless current_user.admin?
    end
<<<   GREEN

git add .
git commit -m 'Done with user edit/update, index, and destroy actions'
git checkout master
git merge updating-users


>>>>>>>>> Capitulo 11 - User microposts


git checkout -b user-microposts    >> Criando o branch

rails generate model Micropost content:string user_id:integer
vi db/migrate/<timestamp>_create_microposts.rb    >>> Micropost migration. added indexes.
  def self.up
    create_table :microposts do |t|
      t.string :content
      t.integer :user_id

      t.timestamps
    end
    add_index :microposts, :user_id
    add_index :microposts, :created_at
  end
<<<
rake db:migrate
rake db:test:prepare

vi micropost.rb    >>> Making the content attribute (and only it) accessible. Importante!!! Algo como Micropost.new(:content => 'foo bar', :user_id => 17) passa a não funcionar.
  attr_accessible :content
<<<
vi micropost_spec.rb   >>> Initial Micropost spec.
  before(:each) do
    @attr = {
      :content => 'value for content',
      :user_id => 1
    }
  end
  
  it 'should create a new instance given valid attributes' do
    Micropost.create!(@attr)
  end
<<<   GREEN

vi micropost_spec.rb    >>> Tests for the micropost's user association.
describe Micropost do
  before(:each) do
    @user = Factory(:user)
    @attr = { :content => 'value for content' }
  end
  it 'should create a new instance given valid attributes' do
    @user.microposts.create!(@attr)
  end
  describe 'user associations' do
    before(:each) do
      @micropost = @user.microposts.create(@attr)
    end
    it 'should have a user attribute' do
      @micropost.should respond_to(:user)
    end
    it 'should have the right associated user' do
      @micropost.user_id.should == @user.id
      @micropost.user.should == @user
    end
  end
end
<<<    RED (3)
vi user_spec.rb   >>> A test for the user's microposts attribute.
  describe 'micropost associations' do
    before(:each) do
      @user = User.create(@attr)
    end
    it 'should have a microposts attribute' do
      @user.should respond_to(:microposts)
    end
  end
<<<   RED (4)
vi micropost.rb   >>> A micropost belongs_to a user.
  belongs_to :user
<<<
vi user.rb       >>> A user has_many microposts
  has_many :microposts
<<<   GREEN

vi spec/factories.rb  >>> Including a new factory for microposts.
Factory.define :micropost do |micropost|
  micropost.content 'Foo bar'
  micropost.association :user
end
<<<
vi user_spec.rb    >>> Testing the order of a user's microposts.
  describe 'micropost associations' do
    before(:each) do
      @user = User.create(@attr)
      @mp1 = Factory(:micropost, :user => @user, :created_at => 1.day.ago)
      @mp2 = Factory(:micropost, :user => @user, :created_at => 1.hour.ago)
    end
    it 'should have a microposts attribute' do
      @user.should respond_to(:microposts)
    end
    it 'should have th right microposts in the right order' do
      @user.microposts.should == [ @mp2, @mp1 ]
    end
  end
<<<    RED (1)
vi micropost.rb    >>> Ordering the microposts with default_scope.
  default_scope :order => 'microposts.created_at DESC'
<<<    GREEN
vi user_spec.rb    >>>  Testing that microposts are destroyed when users are.
    it 'should destroy associated microposts' do
      @user.destroy
      [ @mp1, @mp2 ].each do |micropost|
        Micropost.find_by_id( micropost.id ).should be_nil
      end
    end
<<<    RED (1)
vi user.rb    >>> Ensuring that a user's microposts are destroyed along with the user.
  has_many :microposts, :dependent => :destroy
<<<    GREEN

vi micropost_spec.rb    >>>  Tests for the Micropost model validations.
  describe 'validations' do
    it 'should require a user id' do
      Micropost.new(@attr).should_not be_valid
    end
    it 'should require nonblank content' do
      @user.microposts.build( :content => '  ' ).should_not be_valid
    end
    it 'should reject long content' do
      @user.microposts.build( :content => 'a' * 141 ).should_not be_valid
    end
  end
<<<    RED (3)
vi micropost.rb    >>> The Micropost model validations.
  belongs_to :user
  validates :content, :presence => true, :length => { :maximum => 140 }
  validates :user_id, :presence => true
  default_scope :order => 'microposts.created_at DESC'
<<<     GREEN

vi users_controller_spec.rb   >>> A test for showing microposts on the user show page.
  describe "GET 'show'" do
    it "should show the user's microposts" do
      mp1 = Factory( :micropost, :user => @user, :content => 'Foo bar' )
      mp2 = Factory( :micropost, :user => @user, :content => 'Barz quux' )
      get :show, :id => @user
      response.should have_selector('span.content', :content => mp1.content)
      response.should have_selector('span.content', :content => mp2.content)
    end
<<<     RED (1)
vi users/show.html.erb    >>>  Adding microposts to the user show page.
	  </h1>
	  <% unless @user.microposts.empty? %>
	    <table class='microposts' summary='User microposts'>
	      <%= render @microposts %>
	    </table>
	    <%= will_paginate @microposts %>
	  <% end %>
	  .
	  .
	  .
      <strong>URL</strong> <%= link_to user_path( @user ), @user %>
      <strong>Microposts</strong> <%= @user.microposts.count %>
<<<     RED (1)
vi microposts/_micropost.html.erb    >>>  A partial for showing a single micropost.
<tr>
  <td class='micropost'>
    <span class='content'><%= micropost.content %></span>
    <span class='timestamp'>
      Posted <%= time_ago_in_words( micropost.created_at ) %> ago.
    </span>
  </td>
</tr>
<<<
vi users_controller.rb    >>> Adding an @microposts instance variable to the user show action.
  def show
    @user = User.find( params[:id] )
    @microposts = @user.microposts.paginate( :page => params[:page] )
    @title = @user.name
  end
<<<    GREEN
vi custom.css    >>>  The CSS for microposts (includes all the CSS for this chapter).
<<<   Adicionado um bocado de CSS.

vi lib/tasks/sample_data.rake    >>>  Adding microposts to the sample data.
namespace :db do
  desc 'Fill database with sample data'
  task :populate => :environment do
  .
  .
  .
  
    User.all(:limit => 6).each do |user|
      50.times do
        user.microposts.create!(:content => Faker::Lorem.sentence(5))
      end
    end
<<<
rake db:populate


*****===> 2011/08/10


>>>>>>>>> 11.3 Manipulating Microposts

vi routes.rb   >>>  Routes for the microposts resource.
  resources :microposts, :only => [:create, :destroy]
<<<

vi microposts_controller_spec.rb   >>> Access control tests for the Microposts controller.
describe MicropostsController do
  render_views
  describe 'access control' do
    it "should deny access to 'create'" do
      post :create
      response.should redirect_to(signin_path)
    end
    it "should deny access to 'destroy'" do
      delete :destroy, :id => 1
      response.should redirect_to(signin_path)
    end
  end
<<<
vi sessions_help.rb    >>> Moving the authenticate method into the Sessions helper.
  def authenticate
    deny_access unless signed_in?
  end
  def deny_access
    store_location
    redirect_to signin_path, :notice => 'Please sign in to access this page.'
  end
<<<
vi users_controller.rb      >>>  Removi o authenticate do users_controller
vi microposts_controller.rb    >>>  Adding authentication to the Microposts controller actions.
class MicropostsController < ApplicationController
  before_filter :authenticate
  def create
  end
  def destroy
  end
end
<<<    GREEN

vi microposts_controller_spec.rb     >>>  Tests for the Microposts controller create action.
  describe "POST 'create'" do
    before(:each) do
      @user = test_sign_in( Factory(:user) )
    end
    describe "failure" do
      before(:each) do
        @attr = { :content => '' }
      end
      it 'should not create a micropost' do
        lambda do
          post :create, :micropost => @attr
        end.should_not change(Micropost, :count)
      end
      it 'should render the home page' do
        post :create, :micropost => @attr
        response.should render_template('pages/home')
      end
    end
    describe "success" do
      before(:each) do
        @attr = { :content => 'Lorem ipsum' }
      end
      it 'should create a micropost' do
        lambda do
          post :create, :micropost => @attr
        end.should change(Micropost, :count).by(1)
      end
      it 'should redirect to the home page' do
        post :create, :micropost => @attr
        response.should redirect_to(root_path)
      end
      it 'should have a flash message' do
        post :create, :micropost => @attr
        flash[:success].should =~ /micropost created/i
      end
    end
  end
<<<     RED (5)
vi microposts_controller.rb       >>>  The Microposts controller create action.
  def create
    @micropost = current_user.microposts.build( params[:micropost] )
    if @micropost.save
      flash[:success] = 'Micropost created!'
      redirect_to root_path
    else
      render 'pages/home'
    end
  end
<<<    GREEN
vi pages/home.html.erb     >>>  Adding microposts creation to the Home page.
<% if signed_in? %>
  <table class='front' summary='For signed-in users'>
    <tr>
      <td class='main'>
        <h1 class='micropost'>What's up?</h1>
        <%= render 'shared/micropost_form' %>
      </td>
      <td class='sidebar round'>
        <%= render 'shared/user_info' %>
      </td>
    </tr>
  </table>
<% else %>
  <h1>Sample App</h1>
  <p>
	This is the home page for the <%= link_to 'Ruby on Rails Tutorial', 'http://railstutorial.org/' %> sample application.
  </p>
  <%= link_to "Sign up now!", signup_path, :class => "signup_button round" %>
<% end %>
<<<     RED (4)
vi shared/_micropost_form.html.erb      >>> The form partial for creating microposts
<%= form_for @micropost do |f| %>
  <%= render 'shared/error_messages', :object => f.object %>
  <div class='field'>
    <%= f.text_area :content %>
  </div>
  <div class='actions'>
    <%= f.submit 'Submit' %>
  </div>
<% end %>
<<<
vi shared/_user_info.html.erb         >>>  The partial for the user info sidebar.
<div class='user_info'>
  <a href="<%= user_path(current_user) %>">
    <%= gravatar_for current_user, :size => 30 %>
    <span class='user_name'>
      <%= current_user.name %>
    </span>
    <span class='microposts'>
      <%= pluralize(current_user.microposts.count, 'micropost') %>
    </span>
  </a>
</div>
<<<
vi pages_controller.rb        >>>  Adding a micropost instance variable to the home action.
  def home 
    @title = 'Home'
    @micropost = Micropost.new if signed_in?
  end
<<<     GREEN

vi user_spec.rb              >>> Tests for the (proto-)status feed.
  describe 'micropost associations' do
    describe 'status feed' do
      it 'should have a feed' do
        @user.should respond_to(:feed)
      end
      it "should include the user's microposts" do
        @user.feed.include?(@mp1).should be_true
        @user.feed.include?(@mp2).should be_true
      end
      it "should not include a different user's microposts" do
        mp3 = Factory( :micropost,
                       :user => Factory(:user, :email => Factory.next(:email)) )
       @user.feed.include?(mp3).should be_false
      end
    end
<<<        RED (3)
vi user.rb               >>>  A preliminary implementation for the micropost status feed.
  def feed
    # This is preliminary. See Chapter 12 for the full implementation.
    Micropost.where('user_id = ?', id)
  end
<<<     GREEN

vi pages_controller.rb     >>>  Adding a feed instance variable to the home action.
  def home 
    @title = 'Home'
    if signed_in?
      @micropost = Micropost.new
      @feed_items = current_user.feed.paginate( :page => params[:page] )
    end
  end
<<<
vi shared/_feed.html.erb       >>> The status feed partial.
<% unless @feed_items.empty? %>
  <table class='microposts' summary='User microposts'>
    <%= render :partial => 'shared/feed_item', :collection => @feed_items %>
  </table>
  <% will_paginate @feed_items %>
<% end %>
<<<
vi shared/_feed_item.html.erb     >>> A partial for a single feed item.
<tr>
  <td class='gravatar'>
    <%= link_to gravatar_for( feed_item.user ), feed_item.user %>
  </td>
  <td class='micropost'>
    <span class='user'>
      <%= link_to feed_item.user.name, feed_item.user %>
    </span>
    <span class='content'><%= feed_item.content %></span>
    <span class='timestamp'>
      Posted <%= time_ago_in_words( feed_item.created_at ) %> ago.
    </span>
  </td>
  <% if current_user?(feed_item.user) %>
  <td>
    <%= link_to 'delete', feed_item, :method => :delete,
                                     :confirm => 'You sure?',
                                     :title => feed_item.content %>
  </td>
  <% end %>
</tr>
<<<
vi pages/home.html.erb        >>>  Adding a status feed to the Home page.
        <%= render 'shared/micropost_form' %>
        <%= render 'shared/feed' %>
<<<   RED (2)
vi microposts_controller.rb    >>>  Adding en (empty) @feed_items instance var to the create action.
  def create
    else
      @feed_items = [ ]
      render 'pages/home'
<<<    GREEN

vi microposts/_micropost.html.erb        >>> A partial for showing a single micropost.
  <% if current_user?(micropost.user) %>
    <td>
      <%= link_to  'delete', micropost, :method => :delete,
                                        :confirm => 'You sure?',
                                        :title => micropost.content %>
    </td>
  <% end %>
</tr>
<<<

vi microposts_controller_spec.rb        >>> Tests for the Microposts controller destroy action.
  describe "DELETE 'destroy'" do
    describe 'for an unauthorized user' do
      before(:each) do
        @user = Factory(:user)
        wrong_user = Factory( :user, :email => Factory.next(:email) )
        test_sign_in(wrong_user)
        @micropost = Factory( :micropost, :user => @user )
      end
      it 'should deny access' do
        delete :destroy, :id => @micropost
        response.should redirect_to( root_path )
      end
    end
    describe 'for an authorized user' do
      before(:each) do
        @user = test_sign_in( Factory(:user) )
        @micropost = Factory( :micropost, :user => @user )
      end
      it 'should destroy the micropost' do
        lambda do
          delete :destroy, :id => @micropost
        end.should change(Micropost, :count).by(-1)
      end
    end
  end
<<<     RED (2)
vi microposts_controller.rb        >>>  The Microposts controller destroy action.
  before_filter :authenticate, :only => [:create, :destroy]
  before_filter :authorized_user, :only => :destroy
  def destroy
    @micropost.destroy
    redirect_back_or root_path
  end
  private
    def authorized_user
      @micropost = current_user.microposts.find_by_id( params[:id] )
      redirect_to root_path if @micropost.nil?
    end
<<<     GREEN


>>>>>>>>>  11.3.5 Testing the new home page

rails generate integration_test microposts

vi requests/microposts_spec.rb   >>>  An Integration_test for the microposts on the home page.
describe "Microposts" do
  before(:each) do
    user = Factory(:user)
    visit signin_path
    fill_in :email,    :with => user.email
    fill_in :password, :with => user.password
    click_button
  end
  describe 'creation' do
    describe 'failure' do
      it 'should not make a new micropost' do
        lambda do
          visit root_path
          fill_in :micropost_content, :with => ''
          click_button
          response.should render_template('pages/home')
          response.should have_selector('div#error_explanation')
        end.should_not change(Micropost, :count)
      end
    end
    describe 'success' do
      it 'should make a new micropost' do
        content = 'Lorem ipsum dolor sit amet'
        lambda do
          visit root_path
          fill_in :micropost_content, :with => content
          click_button
          response.should have_selector('span.content', :content => content)
        end.should change(Micropost, :count).by(1)
      end
    end
  end
end
<<<      GREEN

git add .
git commit -m 'Added user microposts'
git checkout master
git merge user-microposts





